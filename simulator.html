<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Robot Simulator</title>
    <style>
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f0f0f0; }
        #canvas { border: 2px solid #333; background: #fff; }
        #status { position: absolute; top: 10px; left: 10px; padding: 10px; background: #fff; border: 1px solid #ddd; border-radius: 5px; }
        /* In simulator.html, inside the <style> tag */
.overlay-message {
    display: none; /* Hidden by default */
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 40px;
    background: linear-gradient(135deg, #10b981, #059669);
    color: white;
    font-size: 24px;
    font-weight: bold;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    z-index: 100;
}
    </style>
</head>
<body>
    <div id="status">Connection: Disconnected</div>
    <canvas id="canvas" width="650" height="600"></canvas>
    <canvas id="canvas" width="650" height="600"></canvas>
<div id="goalMessage" class="overlay-message">ðŸŽ¯ GOAL REACHED! ðŸŽ¯</div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        let ws;

        let robot = { x: 325, y: 300, size: 18, angle: 0, targetX: 325, targetY: 300, moving: false };
       let goal = { x: 550, y: 80, size: 15, vx: 0, vy: 0 };
        let obstacles = [];
        let collisionCount = 0;

        function connectWebSocket() {
            ws = new WebSocket('ws://localhost:8080');
            ws.onopen = () => { statusEl.textContent = 'Connection: Connected'; statusEl.style.color = 'green'; };
            ws.onclose = () => { statusEl.textContent = 'Connection: Disconnected'; statusEl.style.color = 'red'; };
            ws.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                handleCommand(msg);
            };
        }

        function updateGoal() {
    goal.x += goal.vx;
    goal.y += goal.vy;

    // Bounce off walls
    if (goal.x - goal.size < 0 || goal.x + goal.size > canvas.width) {
        goal.vx *= -1;
    }
    if (goal.y - goal.size < 0 || goal.y + goal.size > canvas.height) {
        goal.vy *= -1;
    }
}

        function handleCommand(msg) {

             document.getElementById('goalMessage').style.display = 'none';

            switch (msg.command) {
                case 'move':
                    robot.targetX = msg.target.x;
                    robot.targetY = msg.target.y;
                    robot.moving = true;
                    break;
                case 'set_obstacles':
                    obstacles = msg.obstacles.map(o => ({...o, size: 25}));
                    break;
                case 'capture_canvas':
                    const imageData = canvas.toDataURL('image/png');
                    ws.send(JSON.stringify({
                        type: 'canvas_captured',
                        image_data: imageData,
                        robot_position: {x: robot.x, y: robot.y},
                        goal_position: {x: goal.x, y: goal.y}
                    }));
                    break;
            }
        }
        
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw Goal
            ctx.fillStyle = 'green';
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.size, 0, Math.PI * 2);
            ctx.fill();
            // Draw Obstacles
            ctx.fillStyle = '#333';
            obstacles.forEach(o => ctx.fillRect(o.x - o.size / 2, o.y - o.size / 2, o.size, o.size));
            // Draw Robot
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(robot.x, robot.y, robot.size, 0, Math.PI * 2);
            ctx.fill();
        }

        function update() {
            if (robot.moving) {
                const dx = robot.targetX - robot.x;
                const dy = robot.targetY - robot.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const speed = 4;

                if (dist > speed) {
                    robot.x += (dx / dist) * speed;
                    robot.y += (dy / dist) * speed;
                } else {
                    robot.x = robot.targetX;
                    robot.y = robot.targetY;
                    robot.moving = false;
                }
            }
            checkCollisions();
            requestAnimationFrame(gameLoop);
        }
        
        function checkCollisions() {
            for (let obs of obstacles) {
                const dist = Math.sqrt((robot.x - obs.x)**2 + (robot.y - obs.y)**2);
                if (dist < robot.size + obs.size / 2) {
                    robot.moving = false;
                    ws.send(JSON.stringify({ type: 'collision' }));
                    // To prevent spamming collision messages, we add a simple cooldown
                    // This is a simplified approach. A better one would track which obstacle was hit.
                    robot.x -= 10; // Move robot back slightly
                }
            }
        }

        // In simulator.html, add this new function
function checkGoalReached() {
    // We need a flag to prevent sending the message over and over
    if (goal.vx === 0) return; // Goal is already caught, do nothing.

    const distance = Math.sqrt((robot.x - goal.x)**2 + (robot.y - goal.y)**2);

    // Check if they are touching
    if (distance < robot.size + goal.size) {
        console.log("GOAL REACHED!");

        // Stop both robot and goal
        robot.moving = false;
        goal.vx = 0;
        goal.vy = 0;

        document.getElementById('goalMessage').style.display = 'block';
        // Tell the server, so the controller knows
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'goal_reached' }));
        }
    }
}

        function gameLoop() {
             updateGoal(); 
            update();
            checkGoalReached(); 
            draw();
        }

        connectWebSocket();
        gameLoop();
    </script>
</body>
</html>